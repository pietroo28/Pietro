<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Partículas Organizando Nome</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: radial-gradient(circle at center, #1a0033, #000);;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mouse = { x: null, y: null };

window.addEventListener('mousemove', function(e){
  mouse.x = e.x;
  mouse.y = e.y;
});

// Texto que será formado
const text = "Pietro Henrique";
const fontSize = 180;

ctx.font = `bold ${fontSize}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";

// Canvas temporário para medir o texto
const textCanvas = document.createElement('canvas');
const textCtx = textCanvas.getContext('2d');
textCanvas.width = canvas.width;
textCanvas.height = canvas.height;
textCtx.font = `bold ${fontSize}px Arial`;
textCtx.textAlign = "center";
textCtx.textBaseline = "middle";
textCtx.fillStyle = "white";
textCtx.fillText(text, canvas.width/2, canvas.height/2);

const particles = [];
const particleCount = 2000; 

class Particle {
  constructor(x, y){
    this.baseX = x;
    this.baseY = y;

    // Começa desorganizada
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;

    this.size = 2 + Math.random() * 1.2;
    this.color = "#ffffff";  // azul neon (pode mudar)
    this.organized = false;  // virou TRUE quando chega ao ponto correto
  }

  draw(){
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }

  update(){
    if (!this.organized) {
      
      let dx = mouse.x - this.x;
      let dy = mouse.y - this.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      // Quando o mouse chega perto → começa organizar
      if(distance < 120){
        // movimento suave para posição final
        this.x += (this.baseX - this.x) * 0.07;
        this.y += (this.baseY - this.y) * 0.07;

        // se estiver suficientemente perto do ponto final → fixa
        if (Math.abs(this.x - this.baseX) < 1 && Math.abs(this.y - this.baseY) < 1) {
          this.organized = true;
          this.x = this.baseX;
          this.y = this.baseY;
        }

      } else {
        // movimento desorganizado até o mouse aproximar
        this.x += (Math.random() - 0.5) * 1.5;
        this.y += (Math.random() - 0.5) * 1.5;
      }

    }
  }
}

// Criar partículas em cima da área do texto
const textData = textCtx.getImageData(0, 0, canvas.width, canvas.height);

for(let y = 0; y < canvas.height; y += 6){
  for(let x = 0; x < canvas.width; x += 6){
    const index = (x + y * canvas.width) * 4;
    if(textData.data[index + 3] > 128){ 
      particles.push(new Particle(x, y));
    }
  }
}

// Loop de animação
function animate(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  particles.forEach(p => {
    p.update();
    p.draw();
  });

  requestAnimationFrame(animate);
}
animate();

// Ajustar canvas ao redimensionar janela
window.addEventListener('resize', function(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>
</body>
</html>
